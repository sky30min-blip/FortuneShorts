# -*- coding: utf-8 -*-
"""
ë©”íƒ€ë°ì´í„° ìƒì„± ëª¨ë“ˆ
OpenAI GPTë¥¼ ì‚¬ìš©í•œ ì œëª©/ì„¤ëª…/í•´ì‹œíƒœê·¸ ìë™ ìƒì„±
"""
import json
from datetime import datetime
from typing import List, Optional

import config

# OpenAI í´ë¼ì´ì–¸íŠ¸ (API í‚¤ëŠ” config ë˜ëŠ” ëŸ°íƒ€ì„ì— ì„¤ì •)
_openai_client = None


def _get_client():
    """OpenAI í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜ (ì§€ì—° ì´ˆê¸°í™”)"""
    global _openai_client
    if _openai_client is None:
        try:
            from openai import OpenAI
            _openai_client = OpenAI(api_key=config.OPENAI_API_KEY or "")
        except Exception:
            pass
    return _openai_client


def generate_empathy_ment(topic: str) -> str:
    """
    ê°ì„±í˜• íƒ€ë¡œìš© ê³µê° ë©˜íŠ¸ 1ê°œ ìƒì„±.
    ì£¼ì œ(ì¸ë„¤ì¼=ì˜ìƒ ì œëª©)ì— ë§ì¶° ì‹œì²­ìë¥¼ ëŒì–´ë‹¹ê¸°ëŠ” ë¬¸ì¥.
    í˜•ì‹: ê³µê° ì§ˆë¬¸/ìƒí™© ì œì‹œ + "~ê°€ ê¶ê¸ˆí•˜ì‹œë©´ ë‹¤ìŒ ì¹´ë“œ ì¤‘ í•œ ì¥ì„ ê³¨ë¼ë³´ì„¸ìš”"
    """
    client = _get_client()
    if not client or not config.OPENAI_API_KEY:
        return f"{topic}ì´ ê¶ê¸ˆí•˜ì‹œë©´ ë‹¤ìŒ ì¹´ë“œ ì¤‘ í•œ ì¥ì„ ê³¨ë¼ë³´ì„¸ìš”."

    prompt = f"""ê°ì„±í˜• íƒ€ë¡œ ìœ íŠœë¸Œ ìˆì¸ ìš© ê³µê° ë©˜íŠ¸ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.

[ì£¼ì œ (ì¸ë„¤ì¼=ì˜ìƒ ì œëª©)]
{topic}

[ìš”êµ¬ì‚¬í•­]
- ì˜ìƒì—ì„œ ì£¼ì œ í™”ë©´ 2ì´ˆ í›„ ë‚˜ì˜¬ ë©˜íŠ¸ (ì¸ë„¤ì¼ì´ ì£¼ì œì™€ ë™ì¼)
- ì‹œì²­ìê°€ "ë§ì•„, ë‚˜ ê·¸ê±° ê¶ê¸ˆí•´" í•˜ê³  ë‹¤ë¥¸ í™”ë©´ ëª» ëŒë¦¬ê²Œ í•´ì•¼ í•¨
- 1~2ë¬¸ì¥: ê³µê° ì§ˆë¬¸/ìƒí™© ì œì‹œ â†’ "~ê°€ ê¶ê¸ˆí•˜ì‹œë©´ ë‹¤ìŒ ì¹´ë“œ ì¤‘ í•œ ì¥ì„ ê³¨ë¼ë³´ì„¸ìš”" ë¡œ ëë‚´ê¸°
- 80~120ì ë‚´ì™¸
- ìì—°ìŠ¤ëŸ½ê³  ì§„ì‹¬ ì–´ë¦° í†¤
- ì ˆëŒ€ ë‹¨ì •Â·í˜‘ë°•Â·ê³µí¬ ì¡°ì¥ ê¸ˆì§€

ê³µê° ë©˜íŠ¸ë§Œ í•œ ì¤„ë¡œ ì¶œë ¥ (ë”°ì˜´í‘œÂ·ì„¤ëª… ì—†ì´):"""

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.8,
        )
        ment = (resp.choices[0].message.content or "").strip().strip('"')
        return ment if ment else f"{topic}ì´ ê¶ê¸ˆí•˜ì‹œë©´ ë‹¤ìŒ ì¹´ë“œ ì¤‘ í•œ ì¥ì„ ê³¨ë¼ë³´ì„¸ìš”."
    except Exception:
        return f"{topic}ì´ ê¶ê¸ˆí•˜ì‹œë©´ ë‹¤ìŒ ì¹´ë“œ ì¤‘ í•œ ì¥ì„ ê³¨ë¼ë³´ì„¸ìš”."


def set_openai_api_key(api_key: str) -> None:
    """ì•±ì—ì„œ API í‚¤ë¥¼ ì„¤ì •í•  ë•Œ í˜¸ì¶œ (ì„¸ì…˜ìš©)"""
    global _openai_client
    if api_key:
        try:
            from openai import OpenAI
            _openai_client = OpenAI(api_key=api_key)
        except Exception:
            _openai_client = None
    else:
        _openai_client = None


def generate_titles(
    fortune_type: str,
    date: Optional[str] = None
) -> List[str]:
    """
    ìœ íŠœë¸Œ ì‡¼ì¸  ì œëª© 3ê°€ì§€ ìƒì„±

    Args:
        fortune_type: "ê¸ˆì „ìš´", "ì• ì •ìš´", "ê±´ê°•ìš´", "ì´ìš´"
        date: "2ì›” 10ì¼" (Noneì´ë©´ ì˜¤ëŠ˜ ë‚ ì§œ)

    Returns:
        ì œëª© 3ê°œ ë¦¬ìŠ¤íŠ¸
    """
    if date is None:
        date = datetime.now().strftime("%mì›” %dì¼")

    prompt = f"""
[ì˜¤ëŠ˜ì˜ ìš´ì„¸ íƒ€ë¡œ ì‡¼ì¸ ] ìœ íŠœë¸Œ ì œëª© 3ê°€ì§€ ìƒì„±.
- ì˜¤ëŠ˜ì˜ ìš´ì„¸Â·ì°¸ê³ í•´ì„œ í–‰ë™í•  ì ì´ ë‹´ê¸´ ì˜ìƒì„ì„ ëŠë¼ê²Œ
- í˜¸ê¸°ì‹¬ ìê·¹: ì¹´ë“œë¥¼ ê³ ë¥´ë©´ ì˜¤ëŠ˜ ì°¸ê³ í•  ìƒí™©Â·í–‰ë™ì´ ë‚˜ì˜¨ë‹¤ëŠ” ëŠë‚Œ
- ê¸¸ì´: 40~55ì, ì´ëª¨ì§€ 1~2ê°œ

ì˜ˆì‹œ:
- "{date} ì˜¤ëŠ˜ ê³ ë¥¸ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” ì°¸ê³ í•  ì , ë”ë³´ê¸°ì—ì„œ í™•ì¸í•´ìš” âœ¨"
- "ì˜¤ëŠ˜ ë‚˜ì—ê²Œ í•´ë‹¹í•  ìƒí™©Â·í–‰ë™ì´ ì¹´ë“œì— ìˆì–´ìš” (ì„¤ëª…ë€ì— ì •ë¦¬)"
- "ì˜¤ëŠ˜ í•˜ë£¨ ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ, í•œ ì¥ì˜ ì¹´ë“œê°€ ì•Œë ¤ì¤„ê²Œìš” ğŸ”®"

JSON: {{"titles": ["ì œëª©1", "ì œëª©2", "ì œëª©3"]}}
"""

    client = _get_client()
    if not client or not config.OPENAI_API_KEY:
        return [
            f"ì˜¤ëŠ˜ ê³ ë¥¸ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” ì°¸ê³ í•  ì , ë”ë³´ê¸°ì—ì„œ í™•ì¸í•´ìš” âœ¨",
            f"ì˜¤ëŠ˜ í•˜ë£¨ ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ, ì¹´ë“œê°€ ì•Œë ¤ì¤„ê²Œìš” ğŸ”®",
            f"ì˜¤ëŠ˜ ë‚˜ì—ê²Œ í•´ë‹¹í•  ìƒí™©Â·í–‰ë™, ì„¤ëª…ë€ì— ì •ë¦¬í•´ ë‘ì—ˆì–´ìš” ğŸŒ™"
        ]

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"},
            temperature=0.9
        )
        result = json.loads(response.choices[0].message.content)
        return result.get("titles", [
            f"ì˜¤ëŠ˜ ê³ ë¥¸ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” ì°¸ê³ í•  ì , ë”ë³´ê¸°ì—ì„œ í™•ì¸í•´ìš” âœ¨",
            f"ì˜¤ëŠ˜ í•˜ë£¨ ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ, ì¹´ë“œê°€ ì•Œë ¤ì¤„ê²Œìš” ğŸ”®",
            f"ì˜¤ëŠ˜ ë‚˜ì—ê²Œ í•´ë‹¹í•  ìƒí™©Â·í–‰ë™, ì„¤ëª…ë€ì— ì •ë¦¬í•´ ë‘ì—ˆì–´ìš” ğŸŒ™"
        ])
    except Exception as e:
        print(f"âŒ ì œëª© ìƒì„± ì‹¤íŒ¨: {e}")
        return [
            f"ì˜¤ëŠ˜ ê³ ë¥¸ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” ì°¸ê³ í•  ì , ë”ë³´ê¸°ì—ì„œ í™•ì¸í•´ìš” âœ¨",
            f"ì˜¤ëŠ˜ í•˜ë£¨ ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ, ì¹´ë“œê°€ ì•Œë ¤ì¤„ê²Œìš” ğŸ”®",
            f"ì˜¤ëŠ˜ ë‚˜ì—ê²Œ í•´ë‹¹í•  ìƒí™©Â·í–‰ë™, ì„¤ëª…ë€ì— ì •ë¦¬í•´ ë‘ì—ˆì–´ìš” ğŸŒ™"
        ]


def _get_fortune_type_intro(fortune_type: str) -> str:
    """ìš´ì„¸ ì¢…ë¥˜ë³„ ì„¤ëª…ë€ ë„ì…ë¬¸ (ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ~ì…ë‹ˆë‹¤)"""
    intros = {
        "ê±´ê°•ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ê±´ê°•ìš´ì…ë‹ˆë‹¤. ê±´ê°•ìš´ì€ ì™„ë“œ(ê¶Œæ–) 14ì¥ìœ¼ë¡œ, í™œë ¥Â·ì—ë„ˆì§€Â·ë„ì „ì˜ ê¸°ìš´ì„ ì½ìŠµë‹ˆë‹¤. ëª¸ê³¼ ë§ˆìŒì˜ ê· í˜•, ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ í•„ìš”í•œ ë©”ì‹œì§€ë¥¼ ì¹´ë“œê°€ ì „í•´ì¤ë‹ˆë‹¤.",
        "ì• ì •ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì• ì •ìš´ì…ë‹ˆë‹¤. ì• ì •ìš´ì€ ì»µ(ì„±ë°°) 14ì¥ìœ¼ë¡œ, ê°ì •Â·ì‚¬ë‘Â·ì¸ê°„ê´€ê³„ì˜ íë¦„ì„ ì½ìŠµë‹ˆë‹¤. ë§ˆìŒì´ ëŒë¦¬ëŠ” ëŒ€ìƒ, ê´€ê³„ì˜ ê¹Šì´, ê°ì •ì˜ ì”¨ì•—ì´ ì¹´ë“œì— ë‹´ê²¨ ìˆìŠµë‹ˆë‹¤.",
        "ê¸ˆì „ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ê¸ˆì „ìš´ì…ë‹ˆë‹¤. ê¸ˆì „ìš´ì€ íœíƒ€í´(ë™ì „) 14ì¥ìœ¼ë¡œ, ë¬¼ì§ˆÂ·ì¬ë¬¼Â·ê¸°íšŒì˜ ê¸°ìš´ì„ ì½ìŠµë‹ˆë‹¤. ëˆì˜ íë¦„, í˜„ì‹¤ì ì¸ ê²°ì‹¤, ê²½ì œì  ë©”ì‹œì§€ë¥¼ ì¹´ë“œê°€ ì•Œë ¤ì¤ë‹ˆë‹¤.",
        "ì˜ì‚¬ê²°ì •": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì˜ì‚¬ê²°ì •ì…ë‹ˆë‹¤. ì˜ì‚¬ê²°ì •ì€ ì†Œë“œ(ê²€) 14ì¥ìœ¼ë¡œ, ìƒê°Â·ê²°ë‹¨Â·ê°ˆë“±ì˜ í•´ì†Œë¥¼ ì½ìŠµë‹ˆë‹¤. ê³ ë¯¼ë˜ëŠ” ì„ íƒ, ë¨¸ë¦¿ì† ë³µì¡í•œ ê°ì •, ëª…í™•í•œ ë°©í–¥ì„ ì¹´ë“œê°€ ë¹„ì¶°ì¤ë‹ˆë‹¤.",
        "ë°©í–¥ê³¼ íƒœë„": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ë°©í–¥ê³¼ íƒœë„ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì•„ì¹¨ì˜ ê¸°ìš´, ì˜¤ëŠ˜ í•˜ë£¨ ë‹¹ì‹ ì˜ íƒœë„ì™€ ë°©í–¥ì„ ì½ìŠµë‹ˆë‹¤. ì¸ìƒì˜ í° íë¦„ ì†ì—ì„œ ë‚´ë©´ì˜ ë©”ì‹œì§€ë¥¼ ì „í•´ì¤ë‹ˆë‹¤.",
        "í™œë ¥ê³¼ ì ê²€": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” í™œë ¥ê³¼ ì ê²€ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ë‚®ì˜ í™œë ¥, ë°˜ë³µë˜ëŠ” ì¼ìƒ ì†ì—ì„œ ì ê²€í•  ë¶€ë¶„ì„ ì½ìŠµë‹ˆë‹¤. ì‰¼ê³¼ ì„±ì°°ì˜ ë©”ì‹œì§€ë¥¼ ì¹´ë“œê°€ ì „í•©ë‹ˆë‹¤.",
        "ìƒˆë¡œìš´ ì‹œì‘ê³¼ ëª°ì…": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ìƒˆë¡œìš´ ì‹œì‘ê³¼ ëª°ì…ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì €ë…ì˜ ì—ë„ˆì§€, ëª°ì…í•  ì¼ê³¼ ìƒˆë¡œìš´ ì‹œì‘ì— ëŒ€í•œ ë©”ì‹œì§€ë¥¼ ì½ìŠµë‹ˆë‹¤. ë°¤ì„ ë°í ë‹¹ì‹ ë§Œì˜ ê¸¸ì„ ì¹´ë“œê°€ ë¹„ì¶°ì¤ë‹ˆë‹¤.",
        "ì´ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì´ìš´ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì¸ìƒì˜ í° íë¦„ê³¼ ë‹¹ì‹ ì˜ ë‚´ë©´ì„ ì½ìŠµë‹ˆë‹¤. ì˜¤ëŠ˜ í•˜ë£¨ ì „ì²´ì˜ ê¸°ìš´ê³¼ ë©”ì‹œì§€ë¥¼ ì¹´ë“œê°€ ì „í•´ì¤ë‹ˆë‹¤.",
        "ì§ì¥ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì§ì¥ìš´ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì»¤ë¦¬ì–´Â·ì—…ë¬´Â·ì§ì¥ ì•ˆì˜ ê¸°ìš´ì„ ì½ìŠµë‹ˆë‹¤. ìŠ¹ì§„, ì´ì§, ì¸ê°„ê´€ê³„ê¹Œì§€ ì¹´ë“œê°€ ë‹¹ì‹ ì˜ ì§ì¥ ìƒí™œì— ëŒ€í•œ ë©”ì‹œì§€ë¥¼ ì „í•´ì¤ë‹ˆë‹¤.",
        "í•™ì—…ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” í•™ì—…ìš´ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ê³µë¶€Â·ì‹œí—˜Â·í•©ê²©ì˜ ê¸°ìš´ì„ ì½ìŠµë‹ˆë‹¤. ìˆ˜í—˜ìƒê³¼ í•™ìŠµìë¥¼ ìœ„í•œ ì˜¤ëŠ˜ì˜ ë©”ì‹œì§€ë¥¼ ì¹´ë“œê°€ ì „í•´ì¤ë‹ˆë‹¤.",
        "ì¸ê°„ê´€ê³„ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì¸ê°„ê´€ê³„ìš´ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì¹œêµ¬Â·ë™ë£ŒÂ·ê°€ì¡±Â·ì£¼ë³€ì¸ê³¼ì˜ ê´€ê³„ íë¦„ì„ ì½ìŠµë‹ˆë‹¤. ì˜¤ëŠ˜ ë‹¹ì‹ ì„ ë‘˜ëŸ¬ì‹¼ ì‚¬ëŒë“¤ê³¼ì˜ ê¸°ìš´ì„ ì¹´ë“œê°€ ë¹„ì¶°ì¤ë‹ˆë‹¤.",
        "ì¬íšŒÂ·ì´ë³„ìš´": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì¬íšŒÂ·ì´ë³„ìš´ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ê³¼ê±° ì¸ì—°, ì´ë³„ê³¼ ì¬íšŒì— ëŒ€í•œ ë©”ì‹œì§€ë¥¼ ì½ìŠµë‹ˆë‹¤. ê·¸ ì‚¬ëŒê³¼ì˜ ì¸ì—°ì´ ì¹´ë“œì— ë‹´ê²¨ ìˆì–´ìš”.",
        "ì¬íšŒ ë° ë¯¸ë ¨": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì¬íšŒ ë° ë¯¸ë ¨ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì „ ì• ì¸Â·ì¬íšŒÂ·ë¯¸ë ¨ì— ëŒ€í•œ ì§ˆë¬¸ì— ë‹µí•©ë‹ˆë‹¤. ê·¸ ì‚¬ëŒì˜ ë§ˆìŒ, ì—°ë½ íƒ€ì´ë°, ìš´ëª…ì˜ ì¸ì—°ê¹Œì§€ ì¹´ë“œê°€ ì½ì–´ì¤ë‹ˆë‹¤.",
        "ì¸ & ì§ì‚¬ë‘": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ì¸ & ì§ì‚¬ë‘ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì¸Â·ì§ì‚¬ë‘Â·ê³ ë°± íƒ€ì´ë°Â·ìƒëŒ€ì˜ ë§ˆìŒì„ ì½ìŠµë‹ˆë‹¤. ê·¸ ì‚¬ëŒ ëˆˆì— ë¹„ì¹œ ë‚˜, ê´€ê³„ì˜ ì „í™˜ì ì„ ì¹´ë“œê°€ ì•Œë ¤ì¤ë‹ˆë‹¤.",
        "ê´€ê³„ì˜ ë¹„ë°€": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ê´€ê³„ì˜ ë¹„ë°€ì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ì—°ì¸Â·ì¸ ìƒëŒ€ì˜ ìˆ¨ì€ ë§ˆìŒ, ì§„ì‹¤, ê´€ê³„ì˜ ê¹Šì´ë¥¼ ì½ìŠµë‹ˆë‹¤. ë§ ëª» í•  ë¹„ë°€ê³¼ ì§„ì§œ ì´ìœ ê°€ ì¹´ë“œì— ë‹´ê²¨ ìˆì–´ìš”.",
        "ìš´ì„¸ ë° ê¸°íšŒ": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” ìš´ì„¸ ë° ê¸°íšŒì…ë‹ˆë‹¤. ë©”ì´ì € ì•„ë¥´ì¹´ë‚˜ 22ì¥ìœ¼ë¡œ, ëˆë³µÂ·ê·€ì¸Â·ì§ì—…ìš´Â·ë¬¸ì„œìš´Â·ëŒ€ë°• íƒ€ì´ë°ì„ ì½ìŠµë‹ˆë‹¤. ì¡°ë§Œê°„ ì°¾ì•„ì˜¬ ê¸°íšŒì™€ ì¡°ì‹¬í•  ì ì„ ì¹´ë“œê°€ ì „í•´ì¤ë‹ˆë‹¤.",
        "ì˜¤ëŠ˜ì˜ ìš´ì„¸": "ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ì…ë‹ˆë‹¤. ë½‘íŒ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” **ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ í•´ë‹¹í•  ìƒí™©**ê³¼ **ì°¸ê³ í•´ì„œ í–‰ë™í•  ì **ì„ ì•„ë˜ì— ì •ë¦¬í•´ ë‘ì—ˆì–´ìš”. ì½ì–´ë³´ì‹œê³  ì˜¤ëŠ˜ í•˜ë£¨ ì°¸ê³ í•˜ì‹œë©´ ë©ë‹ˆë‹¤.",
    }
    _n = getattr(config, "NUM_CARDS", 6)
    return intros.get(fortune_type, f"ì˜¤ëŠ˜ì˜ íƒ€ë¡œìš´ì„¸ëŠ” {fortune_type}ì…ë‹ˆë‹¤. {_n}ì¥ì˜ ì¹´ë“œê°€ ë‹¹ì‹ ì—ê²Œ ì „í•˜ëŠ” ì˜¤ëŠ˜ ì°¸ê³ í•  ë©”ì‹œì§€ë¥¼ ì½ì–´ë³´ì„¸ìš”.")


def generate_detailed_card_descriptions(
    card_metadata: Optional[dict] = None,
    fortune_type: str = "íƒ€ë¡œ",
) -> List[dict]:
    """
    Nì¥ ì¹´ë“œë³„ ìƒì„¸ ë¦¬ë”© (ì˜ë¯¸ 350~400ì + ìš”ì•½). ì‹¬ë„ ìˆê²Œ, í•œê¸€ë§Œ.
    card_metadata.num_cardsê°€ ìˆìœ¼ë©´ í•´ë‹¹ ê°œìˆ˜ ì‚¬ìš© (ê°ì„±í˜• 3ì¥), ì—†ìœ¼ë©´ config.NUM_CARDS(6).
    """
    if not card_metadata:
        return []

    from modules.tarot_meanings import get_card_info

    num_cards = card_metadata.get("num_cards") or getattr(config, "NUM_CARDS", 6)
    cards_after_shuffle = card_metadata.get("cards_after_shuffle", [])
    card_meanings = card_metadata.get("card_meanings", [])
    shuffled_order = card_metadata.get("shuffled_order", list(range(num_cards)))
    hook_text = card_metadata.get("hook_text", "")

    if len(cards_after_shuffle) < num_cards or len(card_meanings) < num_cards:
        return []

    cards_text = "\n".join([
        f"{i+1}ë²ˆ: {get_card_info(cards_after_shuffle[i])['name']} - {card_meanings[shuffled_order[i]] if shuffled_order[i] < len(card_meanings) else ''}"
        for i in range(num_cards)
    ])

    is_empathy = bool(hook_text and hook_text.strip())
    context_line = ""
    if is_empathy:
        context_line = f"\n[ì‹œì²­ì ì§ˆë¬¸/ê´€ì‹¬] {hook_text.strip()}\nì´ ì£¼ì œ ë§¥ë½ì— ë§ì¶° **ë…¼ë¦¬ì Â·ì‹¬ë¦¬ì Â·ê³µê° ê°€ëŠ¥í•œ** í•´ì„ì„ ì‘ì„±í•´ ì£¼ì„¸ìš”. ì¹´ë“œ ìƒì§•ì„ ì´ ë§¥ë½ì— ì—°ê²°í•˜ì—¬ ì˜ë¯¸ë¥¼ í’€ì–´ë‚´ì„¸ìš”. **ìƒë‹´ë°›ëŠ” ëŠë‚Œ**ì´ ë‚˜ë„ë¡ ì‹¬ë„ ìˆê²Œ ì‘ì„±í•˜ì„¸ìš”.\n"

    meaning_len = "400~450ì" if is_empathy else "350~400ì"
    meaning_desc = "**ì •ë§ ìƒë‹´ë°›ëŠ” ëŠë‚Œ**ì´ ë‚˜ë„ë¡ ì‹¬ë„ ìˆê²Œ, ê¹Šì´ ìˆê²Œ ì‘ì„±. (1) ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ í•´ë‹¹í•  ìˆ˜ ìˆëŠ” **ìƒí™©Â·ê²½ìš°**ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ. (2) **ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ**: ì˜¤ëŠ˜ ë¬´ì—‡ì„ í•˜ë©´ ì¢‹ì€ì§€, ë¬´ì—‡ì„ í”¼í•˜ê±°ë‚˜ ì¡°ì‹¬í• ì§€, ì–´ë–¤ ë§ˆìŒê°€ì§ìœ¼ë¡œ ì›€ì§ì´ë©´ ì¢‹ì€ì§€. ë…¼ë¦¬ì Â·ê³µê° ê°€ëŠ¥í•˜ê²Œ. ì¹´ë“œ ìƒì§•ê³¼ ì‹¬ë¦¬ê¹Œì§€ í’ë¶€í•˜ê²Œ. " + ("ê°ì„±í˜• ì£¼ì œì— ë§ì¶° ì‹œì²­ìê°€ 'ë§ì•„, ë‚´ ìƒí™©ì— ë”± ë§ëŠ” ìƒë‹´ì´ë„¤' í•˜ê³  ëŠë¼ë„ë¡." if is_empathy else "")

    prompt = f"""ë‹¹ì‹ ì€ 20ë…„ ê²½ë ¥ì˜ íƒ€ë¡œ ìƒë‹´ì‚¬ì…ë‹ˆë‹¤. {num_cards}ì¥ì˜ ì¹´ë“œì— ëŒ€í•´ **ì˜¤ëŠ˜ì˜ ìš´ì„¸** ë§¥ë½ìœ¼ë¡œ **ì˜ë¯¸**ì™€ **ìš”ì•½**ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.
ë…ìê°€ "ì•„, ì˜¤ëŠ˜ ë‚˜ì—ê²ŒëŠ” ì´ëŸ° ê²½ìš°êµ¬ë‚˜. ì´ê±¸ ì°¸ê³ í•´ì„œ í–‰ë™í•´ì•¼ê² ë‹¤"ë¼ê³  ëŠë¼ê²Œ í•´ì£¼ì„¸ìš”.
**ë°˜ë“œì‹œ í•œê¸€ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”. ì˜ë¬¸Â·ë¡œë§ˆìÂ·ì™¸ë˜ì–´ í‘œê¸°ëŠ” í•œê¸€ë¡œ. í•´ì„ì— ì˜ì–´ê°€ ë‚˜ì˜¤ë©´ ì•ˆ ë©ë‹ˆë‹¤.**
**ì¹´ë“œ ë¦¬ë”©ì€ ë…¼ë¦¬ì ì´ê³  ì‹¬ë¦¬ì ì´ë©° ê³µê°ì„±ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.**
{context_line}
[ë½‘íŒ ì¹´ë“œ] - ì˜¤ëŠ˜ì˜ {fortune_type} ìš´ì„¸
{cards_text}

[í˜•ì‹ - ê° ì¹´ë“œë§ˆë‹¤]
- meaning(ì˜ë¯¸): {meaning_len}. {meaning_desc}
- healing_message(ìš”ì•½): 80~120ì. ìœ„ ì˜ë¯¸ ë‚´ìš©ì„ **í•œ ì¤„ ìš”ì•½**. ë”°ëœ»í•˜ê³  ì‹¤ìƒí™œ ì ìš© ê°€ëŠ¥í•˜ê²Œ.

[âš ï¸ ë°˜ë“œì‹œ ì§€ì¼œì•¼ í•  í‘œí˜„ ê·œì¹™ - ìœ„ë°˜ ê¸ˆì§€]
- ì ˆëŒ€ ë‹¨ì • ì˜ˆì¸¡ ê¸ˆì§€: "100%", "ë°˜ë“œì‹œ", "ë‹¹ì²¨ë©ë‹ˆë‹¤" ë“±
- ê±´ê°•/ì‚¬ë§ ê´€ë ¨ í™•ì • ê¸ˆì§€. ê³µí¬ ì¡°ì¥/í˜‘ë°•í˜• ê¸ˆì§€. íŠ¹ì • ì¸ë¬¼ í™•ì • ë¹„ë‚œ ê¸ˆì§€. ë²•ì /ì¬ì • í™•ì • ê¸ˆì§€.
- íƒ€ë¡œëŠ” ìƒì§• í•´ì„ì´ì§€ ì˜ˆì–¸ì´ ì•„ë‹˜. í†¤ì€ íŒê²°ì´ ì•„ë‹Œ ì•ˆë‚´. "ê°€ëŠ¥ì„±ì´ ì—´ë ¤ ìˆìŠµë‹ˆë‹¤", "ì´ëŸ° íë¦„ì´ ë³´ì…ë‹ˆë‹¤", "ì°¸ê³ í•˜ì‹œë©´ ì¢‹ê² ìŠµë‹ˆë‹¤" ë“±ìœ¼ë¡œ ì™„ì¶©.

JSON (ë‹¤ë¥¸ ì„¤ëª… ì—†ì´):
{{"cards": [{{"meaning": "ì˜ë¯¸ ë¬¸ì¥({meaning_len}, í•œê¸€ë§Œ)", "healing_message": "ìš”ì•½ í•œ ì¤„"}}, ...]}}  // {num_cards}ê°œ
"""

    client = _get_client()
    fallback = []
    for i in range(num_cards):
        info = get_card_info(cards_after_shuffle[i])
        idx = shuffled_order[i] if shuffled_order[i] < len(card_meanings) else i
        m = card_meanings[idx] if idx < len(card_meanings) else info["meaning"]
        fallback.append({
            "name": info["name"],
            "meaning": f"ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ ì´ ì¹´ë“œëŠ” {m}ë¥¼ ì´ì•¼ê¸°í•˜ê³  ìˆì–´ìš”. ì˜¤ëŠ˜ í•´ë‹¹í•  ìˆ˜ ìˆëŠ” ìƒí™©ì„ ë– ì˜¬ë¦¬ë©° ì°¸ê³ í•´ì„œ í–‰ë™í•´ ë³´ì„¸ìš”.",
            "healing_message": f"ì˜¤ëŠ˜ ì´ ì—ë„ˆì§€ë¥¼ ì°¸ê³ í•´ì„œ ì›€ì§ì—¬ ë³´ì„¸ìš”."
        })

    if not client or not config.OPENAI_API_KEY:
        return fallback

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"},
            temperature=0.8,
        )
        data = json.loads(response.choices[0].message.content)
        cards = data.get("cards", [])
        max_meaning_len = 500 if is_empathy else 450
        for i in range(min(num_cards, len(cards))):
            c = cards[i]
            if isinstance(c, dict) and c.get("meaning") and c.get("healing_message"):
                info = get_card_info(cards_after_shuffle[i])
                fallback[i] = {
                    "name": info["name"],
                    "meaning": str(c["meaning"]).strip()[:max_meaning_len],
                    "healing_message": str(c["healing_message"]).strip()[:180]
                }
        return fallback
    except Exception as e:
        print(f"âŒ ì¹´ë“œ ìƒì„¸ ì„¤ëª… ìƒì„± ì‹¤íŒ¨: {e}")
        return fallback


def generate_description(
    fortune_type: str,
    date: Optional[str] = None,
    keywords: Optional[List[str]] = None,
    card_metadata: Optional[dict] = None,
) -> str:
    """
    ìœ íŠœë¸Œ ì„¤ëª…ë€ ìë™ ìƒì„± (íƒ€ë¡œ ì½˜í…ì¸  ë§ì¶¤, Nì¥ ì¹´ë“œ ìƒì„¸ ì„¤ëª… í¬í•¨. N=config.NUM_CARDS)

    Args:
        fortune_type: ìš´ì„¸/í…Œë§ˆ ì¢…ë¥˜
        date: ë‚ ì§œ
        keywords: í–‰ìš´ í‚¤ì›Œë“œ ë¦¬ìŠ¤íŠ¸
        card_metadata: Nì¥ ì¹´ë“œ ì •ë³´ (cards_after_shuffle, card_meanings, shuffled_order)
    """
    if date is None:
        date = datetime.now().strftime("%mì›” %dì¼")

    if keywords is None:
        keywords = ["í–‰ìš´", "ì„±ê³µ", "ê¸°íšŒ", "ë§Œë‚¨", "ëˆ"]

    fortune_intro = _get_fortune_type_intro(fortune_type)

    import random
    card_section = ""
    is_empathy = bool(card_metadata and card_metadata.get("is_empathy"))
    if card_metadata:
        detailed = generate_detailed_card_descriptions(card_metadata, fortune_type)
        if detailed:
            num_cards = len(detailed)
            lucky_nums = []
            if not is_empathy:
                def _make_lucky_nums():
                    nums = [random.randint(1, 9) for _ in range(num_cards)]
                    from collections import Counter
                    while True:
                        c = Counter(nums)
                        bad = [n for n, cnt in c.items() if cnt >= 3]
                        if not bad:
                            return nums
                        for i in range(num_cards):
                            if nums[i] in bad:
                                others = [x for x in range(1, 10) if c.get(x, 0) < 2]
                                if others:
                                    nums[i] = random.choice(others)
                                    break
                    return nums
                lucky_nums = _make_lucky_nums()

            lines = [fortune_intro, ""] if fortune_intro else []
            for i, d in enumerate(detailed):
                name = d.get("name", f"{i+1}ë²ˆ ì¹´ë“œ")
                meaning = d.get("meaning", "")
                healing = d.get("healing_message", "")
                if is_empathy:
                    lines.append(f"""ğŸƒ {i+1}ë²ˆ ì¹´ë“œ: {name}

ì˜ë¯¸: "{meaning}"

ìš”ì•½: "{healing}"

""")
                else:
                    num = lucky_nums[i] if i < len(lucky_nums) else random.randint(1, 9)
                    lines.append(f"""ğŸƒ {i+1}ë²ˆ ì¹´ë“œ: {name}

ì˜ë¯¸: "{meaning}"

ìš”ì•½: "{healing}"

ì˜¤ëŠ˜ì˜ í–‰ìš´ì˜ ìˆ«ìëŠ” {num}ë²ˆ ì…ë‹ˆë‹¤.""")
            card_section = "\n\n".join(lines) + "\n\n"

    description = f"""ì–´ì„œ ì˜¤ì„¸ìš”. ë‹¹ì‹ ì˜ ìš´ëª…ì„ ì½ì–´ë“œë¦¬ëŠ” ê³³, ë‹¬ì˜ì„œì¬ì…ë‹ˆë‹¤. ğŸŒ™

ì˜¤ëŠ˜ì˜ ìš´ì„¸â€”ë‹¹ì‹ ì´ ê³ ë¥¸ ì¹´ë“œê°€ ì•Œë ¤ì£¼ëŠ” **ì˜¤ëŠ˜ í•´ë‹¹í•  ìƒí™©**ê³¼ **ì°¸ê³ í•´ì„œ í–‰ë™í•  ì **ì„ ì •ë¦¬í•´ ë‘ì—ˆìŠµë‹ˆë‹¤.
ì½ì–´ë³´ì‹œê³  "ì˜¤ëŠ˜ ì´ë ‡ê²Œ í•´ì•¼ê² ë‹¤" í•˜ëŠ” ë¶€ë¶„ë§Œ ê³¨ë¼ ì°¸ê³ í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{card_section}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ‘ ì˜ìƒì´ ë„ì›€ì´ ë˜ì…¨ë‹¤ë©´ ì¢‹ì•„ìš” ë¶€íƒë“œë ¤ìš”!
ğŸ”” êµ¬ë…ê³¼ ì•Œë¦¼ìœ¼ë¡œ ë§¤ì¼ ìƒˆë¡œìš´ íƒ€ë¡œ ìš´ì„¸ë¥¼ ë§Œë‚˜ë³´ì„¸ìš”!
ğŸ’¬ ëŒ“ê¸€ë¡œ ì†Œí†µí•´ì£¼ì„¸ìš”!
ğŸ“¢ ì¹œêµ¬ì—ê²Œë„ íƒ€ë¡œ ìš´ì„¸ë¥¼ ê³µìœ í•´ë³´ì„¸ìš”!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ·ï¸ #íƒ€ë¡œ #íƒ€ë¡œìš´ì„¸ #ì˜¤ëŠ˜ìš´ì„¸ #ì˜¤ëŠ˜ì˜íƒ€ë¡œ #íƒ€ë¡œì¹´ë“œ #Shorts
#ìš´ì„¸ #ì  #ì¹´ë“œë¦¬ë”© #ì •ì‹ ì„¸ê³„ #íë§ #ì˜¤ëŠ˜ì°¸ê³ 
#tarot #tarotreading #fortune #horoscope

âš ï¸ ë³¸ ì½˜í…ì¸ ëŠ” ì¬ë¯¸ì™€ íë§ì„ ìœ„í•œ ì°¸ê³ ìš©ì´ë©°, ì¤‘ìš”í•œ ê²°ì •ì€ ì‹ ì¤‘íˆ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”® íƒ€ë¡œ ìš´ì„¸ Shorts
"""
    return description


def generate_hashtags(fortune_type: str, count: int = 15) -> List[str]:
    """
    íƒ€ë¡œ ë§ì¶¤ í•´ì‹œíƒœê·¸ ìë™ ìƒì„±

    Args:
        fortune_type: ìš´ì„¸/í…Œë§ˆ ì¢…ë¥˜
        count: ìƒì„±í•  íƒœê·¸ ê°œìˆ˜

    Returns:
        í•´ì‹œíƒœê·¸ ë¦¬ìŠ¤íŠ¸
    """
    base_tags = [
        "#íƒ€ë¡œ", "#íƒ€ë¡œìš´ì„¸", "#ì˜¤ëŠ˜ìš´ì„¸", "#Shorts", "#ì˜¤ëŠ˜ì˜íƒ€ë¡œ", "#íƒ€ë¡œì¹´ë“œ",
        "#ì¹´ë“œë¦¬ë”©", "#ì ", "#ìš´ì„¸", "#ì˜¤ëŠ˜ì°¸ê³ "
    ]

    type_tags = {
        "ê¸ˆì „ìš´": ["#ê¸ˆì „ìš´", "#ì¬ë¬¼ìš´", "#ë¡œë˜", "#ëŒ€ë°•ìš´"],
        "ì• ì •ìš´": ["#ì• ì •ìš´", "#ì—°ì• ìš´", "#ì‚¬ë‘", "#ì¸ì—°", "#ì†”ë¡œíƒˆì¶œ"],
        "ê±´ê°•ìš´": ["#ê±´ê°•ìš´", "#íë§", "#ì›°ë¹™", "#ë§ˆìŒì±™ê¹€"],
        "ì´ìš´": ["#ì´ìš´", "#ì‹ ë…„ìš´ì„¸", "#í–‰ìš´"],
        "ë°©í–¥ê³¼ íƒœë„": ["#ì•„ì¹¨ìš´ì„¸", "#ì˜¤ëŠ˜ì˜ì—ë„ˆì§€"],
        "í™œë ¥ê³¼ ì ê²€": ["#ì ì‹¬ìš´ì„¸", "#ì¼ìƒìš´ì„¸"],
        "ìƒˆë¡œìš´ ì‹œì‘ê³¼ ëª°ì…": ["#ì €ë…ìš´ì„¸", "#ìƒˆë¡œìš´ì‹œì‘"],
        "ì§ì¥ìš´": ["#ì§ì¥ìš´", "#ì»¤ë¦¬ì–´", "#ìŠ¹ì§„", "#ì´ì§", "#ì§ì¥ì¸"],
        "í•™ì—…ìš´": ["#í•™ì—…ìš´", "#ì‹œí—˜ìš´", "#í•©ê²©", "#ìˆ˜í—˜ìƒ", "#ê³µë¶€"],
        "ì¸ê°„ê´€ê³„ìš´": ["#ì¸ê°„ê´€ê³„", "#ì¹œêµ¬", "#ì¸ì—°", "#ê´€ê³„ìš´"],
        "ì¬íšŒÂ·ì´ë³„ìš´": ["#ì¬íšŒ", "#ì´ë³„", "#ì „ì• ì¸", "#ì¸ì—°ìš´"],
        "ì¬íšŒ ë° ë¯¸ë ¨": ["#ì¬íšŒ", "#ë¯¸ë ¨", "#ì „ì• ì¸", "#ì—°ë½", "#ì¸ì—°ìš´"],
        "ì¸ & ì§ì‚¬ë‘": ["#ì¸", "#ì§ì‚¬ë‘", "#ê³ ë°±", "#ì—°ì• ìš´", "#ì¸íƒ€ë¡œ"],
        "ê´€ê³„ì˜ ë¹„ë°€": ["#ì—°ì• ", "#ê´€ê³„", "#ì§„ì‹¤", "#íƒ€ë¡œë¦¬ë”©", "#ì—°ì¸ìš´"],
        "ìš´ì„¸ ë° ê¸°íšŒ": ["#ìš´ì„¸", "#ëˆë³µ", "#ê·€ì¸", "#ì§ì—…ìš´", "#ëŒ€ë°•ìš´"],
    }

    today = datetime.now()
    date_tags = [
        f"#{today.month}ì›”ìš´ì„¸",
        f"#{today.year}ìš´ì„¸",
        "#ì˜¤ëŠ˜"
    ]

    general_tags = [
        "#tarot", "#tarotreading", "#ì ì„±ìˆ ", "#ì •ì‹ ì„¸ê³„", "#ì‹¬ë¦¬",
        "#horoscope", "#fortune", "#lucky", "#íë§"
    ]

    extra = type_tags.get(fortune_type, [f"#{fortune_type.replace(' ', '')}"])
    all_tags = (
        base_tags
        + extra
        + date_tags
        + general_tags
    )
    unique_tags = list(dict.fromkeys(all_tags))[:count]

    return unique_tags


def generate_tarot_interpretations(
    card_indices: List[int],
    fortune_type: str,
    card_names: Optional[List[str]] = None,
    hook_text_override: Optional[str] = None,
) -> List[str]:
    """
    íƒ€ë¡œ ì¹´ë“œ Nì¥ì— ëŒ€í•œ GPT ë™ì  í•´ì„ (ì „ë¬¸ê°€ ìˆ˜ì¤€). ì˜¤ëŠ˜ì˜ ìš´ì„¸ì— ì–´ìš¸ë¦¬ê²Œ ìƒí™©Â·í–‰ë™ ì°¸ê³ í˜•ìœ¼ë¡œ ìƒì„±.

    Args:
        card_indices: ì¹´ë“œ ì¸ë±ìŠ¤ (0~77), 6ì¥ ë“±
        fortune_type: ì´ìš´, ì˜¤ëŠ˜ì˜ ìš´ì„¸, ì• ì •ìš´, ê¸ˆì „ìš´ ë“±
        card_names: ì¹´ë“œëª… ë¦¬ìŠ¤íŠ¸ (ì—†ìœ¼ë©´ tarot_meaningsì—ì„œ ì¡°íšŒ)
        hook_text_override: ê°ì„±í˜• íƒ€ë¡œ ì‹œ ì„ íƒí•œ ì œëª© (ì§ˆë¬¸ ë§¥ë½ ì „ë‹¬ìš©)

    Returns:
        ì¹´ë“œë³„ í•´ì„ ë¬¸ìì—´ Nê°œ
    """
    from modules.tarot_meanings import get_card_info

    n = len(card_indices)
    if n == 0:
        return []

    if card_names is None:
        card_names = [get_card_info(i)["name"] for i in card_indices]

    cards_text = "\n".join([f"{i+1}ë²ˆ: {card_names[i]}" for i in range(n)])
    interp_placeholders = ", ".join([f'"í•´ì„{i+1}"' for i in range(n)])

    # ëª¨ë“  ì£¼ì œì— ì£¼ì œë³„ ë§¥ë½ ì ìš© (ê°ì„±í˜•: ì„ íƒ ì œëª© / ì•„ì¹¨ ìš´ì„¸: í…Œë§ˆëª…)
    if hook_text_override and hook_text_override.strip():
        topic = hook_text_override.strip()
        context_line = f"""
[ì‹œì²­ì ì§ˆë¬¸/ê´€ì‹¬ - ë°˜ë“œì‹œ ì´ ë§¥ë½ì— ë§ì¶° í•´ì„]
{topic}

**ì´ ì£¼ì œì— ë§ì¶°** ê° ì¹´ë“œë¥¼ í•´ì„í•´ ì£¼ì„¸ìš”. ì¹´ë“œ ìƒì§•ì„ ì´ ìƒí™©ì— ì—°ê²°í•˜ì—¬, ì‹œì²­ìê°€ "ì•„, ë‚´ ìƒí™©ì— ë”± ë§ëŠ” ë¶„ì„ì´êµ¬ë‚˜" í•˜ê³  ê³µê°í•˜ë„ë¡ ì‘ì„±í•˜ì„¸ìš”.
ì§§ì€ í‚¤ì›Œë“œ("ì˜ì§€ë ¥ ì°½ì¡°ì  ì—ë„ˆì§€" ë“±)ë§Œ ë‚˜ì—´í•˜ì§€ ë§ˆì„¸ìš”. ì£¼ì œ ë§¥ë½ì— ë§ëŠ” **ë…¼ë¦¬ì Â·ì‹¬ë¦¬ì Â·ê³µê° ê°€ëŠ¥í•œ** ë¬¸ì¥ìœ¼ë¡œ í’€ì–´ë‚´ì„¸ìš”.
"""
    else:
        topic = fortune_type.strip() if fortune_type else "ì˜¤ëŠ˜ì˜ ìš´ì„¸"
        context_line = f"""
[ì˜ìƒ ì£¼ì œ - ë°˜ë“œì‹œ ì´ ë§¥ë½ì— ë§ì¶° í•´ì„]
ì´ ì˜ìƒì˜ ì£¼ì œëŠ” **{topic}**ì…ë‹ˆë‹¤.

**ì´ ì£¼ì œì— ë§ì¶°** ê° ì¹´ë“œë¥¼ í•´ì„í•´ ì£¼ì„¸ìš”. ì˜ˆ: ì§ì¥ìš´ì´ë©´ ì—…ë¬´Â·ìŠ¹ì§„Â·ëŒ€ì¸ê´€ê³„, í•™ì—…ìš´ì´ë©´ ì‹œí—˜Â·ê³µë¶€Â·ì§‘ì¤‘, ì´ìš´ì´ë©´ ì˜¤ëŠ˜ í•˜ë£¨ ì „ì²´ íë¦„ ë“±. ì¹´ë“œ ìƒì§•ì„ í•´ë‹¹ ìƒí™©ì— ì—°ê²°í•˜ì—¬ ì‹œì²­ìê°€ "ì˜¤ëŠ˜ ë‚˜ì—ê²Œ ë”± ë§ëŠ” ì°¸ê³ ê°€ ë˜ê² ë‹¤" í•˜ê³  ëŠë¼ë„ë¡ ì‘ì„±í•˜ì„¸ìš”.
ì§§ì€ í‚¤ì›Œë“œë§Œ ë‚˜ì—´í•˜ì§€ ë§ˆì„¸ìš”. ì£¼ì œ ë§¥ë½ì— ë§ëŠ” **ë…¼ë¦¬ì Â·ì‹¬ë¦¬ì Â·ê³µê° ê°€ëŠ¥í•œ** ë¬¸ì¥ìœ¼ë¡œ í’€ì–´ë‚´ì„¸ìš”.
"""

    prompt = f"""ë‹¹ì‹ ì€ 20ë…„ ê²½ë ¥ì˜ ì „ë¬¸ íƒ€ë¡œ ë¦¬ë”ì…ë‹ˆë‹¤.
ì˜¤ëŠ˜ì˜ {fortune_type} ìš´ì„¸ë¥¼ ìœ„í•œ {n}ì¥ì˜ ì¹´ë“œê°€ ë½‘í˜”ìŠµë‹ˆë‹¤.
ì‹œì²­ìê°€ í•´ì„ì„ ì½ê³  "ì•„, ì˜¤ëŠ˜ ë‚˜ì—ê²ŒëŠ” ì´ëŸ° ê²½ìš°/ìƒí™©ì´êµ¬ë‚˜. ì´ê±¸ ì°¸ê³ í•´ì„œ í–‰ë™í•´ì•¼ê² ë‹¤"ë¼ê³  ëŠë¼ë„ë¡ ì‘ì„±í•˜ì„¸ìš”.
{context_line}

[ë½‘íŒ ì¹´ë“œ]
{cards_text}

[ìš”êµ¬ì‚¬í•­]
- ê° í•´ì„ì€ 80~120ì ë‚´ì™¸ë¡œ í’ë¶€í•˜ê³  ì„¸ë¶€ì ìœ¼ë¡œ ì‘ì„±
- **ì˜¤ëŠ˜ì˜ ìš´ì„¸**ì— ë§ê²Œ: "ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ í•´ë‹¹í•  ìˆ˜ ìˆëŠ” ìƒí™©Â·ê²½ìš°"ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì œì‹œ (ì˜ˆ: ì¤‘ìš”í•œ ì¼ì •ì´ ìˆë‹¤ë©´, ê²°ì •ì„ ë¯¸ë¤„ì•¼ í•  ì¼ì´ ìˆë‹¤ë©´, ê´€ê³„ì—ì„œ ì¡°ì‹¬í•  ë¶€ë¶„ì´ ìˆë‹¤ë©´ ë“±)
- ì´ì–´ì„œ **ì°¸ê³ í•´ì„œ í–‰ë™í•  ê²ƒ**ì„ ëª…í™•íˆ: ì˜¤ëŠ˜ ë¬´ì—‡ì„ í•˜ë©´ ì¢‹ì€ì§€, ë¬´ì—‡ì„ í”¼í•˜ê±°ë‚˜ ì¡°ì‹¬í•˜ë©´ ì¢‹ì€ì§€, ì–´ë–¤ ë§ˆìŒê°€ì§ìœ¼ë¡œ ì›€ì§ì´ë©´ ì¢‹ì€ì§€
- ì½ëŠ” ì‚¬ëŒì´ "ê·¸ë˜, ì˜¤ëŠ˜ ì´ë ‡ê²Œ í•´ì•¼ê² êµ¬ë‚˜" í•˜ê³  ì‹¤ìƒí™œì— ì ìš©í•  ìˆ˜ ìˆê²Œ
- ì§§ì€ í‚¤ì›Œë“œë‚˜ í•œ ì¤„ ìš”ì•½ ê¸ˆì§€. 2~3ë¬¸ì¥ìœ¼ë¡œ ìƒí™© ì œì‹œ + í–‰ë™ ì°¸ê³  ì‚¬í•­
- "~í•´ë³´ì„¸ìš”", "~í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤", "~í•  ë•Œ ì°¸ê³ í•˜ì„¸ìš”" ë“± êµ¬ì²´ì  í–‰ë™ ì§€ì¹¨ í¬í•¨
- ë‹¨ì •ì  ì˜ˆì¸¡ë³´ë‹¤ëŠ” "ì˜¤ëŠ˜ ì´ëŸ° ì—ë„ˆì§€/ìƒí™©ì´ ìˆìœ¼ë‹ˆ ì´ë ‡ê²Œ ì°¸ê³ í•˜ì„¸ìš”" í†¤ìœ¼ë¡œ

[âš ï¸ ë°˜ë“œì‹œ ì§€ì¼œì•¼ í•  í‘œí˜„ ê·œì¹™ - ìœ„ë°˜ ê¸ˆì§€]
- ì ˆëŒ€ ë‹¨ì • ì˜ˆì¸¡ ê¸ˆì§€: "100% ì—°ë½ ì˜µë‹ˆë‹¤", "ë°˜ë“œì‹œ ì¬íšŒí•©ë‹ˆë‹¤", "ë‹¹ì²¨ë©ë‹ˆë‹¤", "ì´ ì„ íƒì„ í•˜ë©´ ë§í•©ë‹ˆë‹¤" ë“±
- ê±´ê°•/ì‚¬ë§ ê´€ë ¨ í™•ì • ê¸ˆì§€: "í° ë³‘ì´ ì˜µë‹ˆë‹¤", "ì‚¬ê³  ìœ„í—˜", "ì£½ìŒ" ë“±
- ê³µí¬ ì¡°ì¥/í˜‘ë°•í˜• ê¸ˆì§€: "ì´ê±¸ ì•ˆ ë³´ë©´ í›„íšŒí•©ë‹ˆë‹¤" ë“±
- íŠ¹ì • ì¸ë¬¼ í™•ì • ë¹„ë‚œ ê¸ˆì§€: "ê·¸ ì‚¬ëŒì€ ë‚˜ë¥¼ ì†ì´ê³  ìˆìŠµë‹ˆë‹¤" â†’ ëŒ€ì‹  "ì˜ì‹¬ ì—ë„ˆì§€ê°€ ë³´ì…ë‹ˆë‹¤", "ì‹ ë¢°ì— í”ë“¤ë¦¼ì´ ìˆìŠµë‹ˆë‹¤"
- ë²•ì /ì¬ì • í™•ì • ê¸ˆì§€: "ê³„ì•½ ë°˜ë“œì‹œ ì„±ê³µ", "í•©ê²© í™•ì •", "íˆ¬ìí•˜ë©´ ì´ìµ" ë“±
- ì˜ì¡´ ìœ ë„ ê¸ˆì§€: "ì €ë§Œ ë¯¿ìœ¼ì„¸ìš”", "ì´ ì±„ë„ë§Œ ë³´ë©´ ë©ë‹ˆë‹¤" ë“±
- íƒ€ë¡œëŠ” ì˜ˆì–¸ì´ ì•„ë‹ˆë¼ ìƒì§• í•´ì„. í†¤ì€ íŒê²°ì´ ì•„ë‹Œ ì•ˆë‚´.

[ì•ˆì „í•œ í‘œí˜„ íŒ¨í„´ ì‚¬ìš©]
- "ê°€ëŠ¥ì„±ì´ ì—´ë ¤ ìˆìŠµë‹ˆë‹¤", "ì´ëŸ° íë¦„ì´ ë³´ì…ë‹ˆë‹¤", "ì´ëŸ° ì—ë„ˆì§€ê°€ ê°•í•©ë‹ˆë‹¤"
- "ì„ íƒì— ë”°ë¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤", "ì°¸ê³ í•˜ì‹œë©´ ì¢‹ê² ìŠµë‹ˆë‹¤", "ì¡°ì‹¬í•˜ëŠ” í¸ì´ ì¢‹ê² ìŠµë‹ˆë‹¤"
- Do not make guaranteed predictions. Interpret energy and possibility only. Avoid medical, death, legal, financial certainty.

JSON í˜•ì‹ìœ¼ë¡œë§Œ ë°˜í™˜ (ë‹¤ë¥¸ ì„¤ëª… ì—†ì´):
{{"interpretations": [{interp_placeholders}]}}
"""

    client = _get_client()
    if not client or not config.OPENAI_API_KEY:
        return [get_card_info(i)["meaning"] for i in card_indices]

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"},
            temperature=0.7,
        )
        result = json.loads(response.choices[0].message.content)
        interps = result.get("interpretations", [])
        if len(interps) >= n:
            return [str(s).strip()[:150] for s in interps[:n]]
        # ë¶€ì¡±í•˜ë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì±„ì›€
        fallbacks = [get_card_info(i)["meaning"] for i in card_indices]
        for i, v in enumerate(interps):
            if i < n and v:
                fallbacks[i] = str(v).strip()[:150]
        return fallbacks
    except Exception as e:
        print(f"âŒ íƒ€ë¡œ í•´ì„ ìƒì„± ì‹¤íŒ¨: {e}")
        return [get_card_info(i)["meaning"] for i in card_indices]


def generate_fortune_text(fortune_type: str) -> str:
    """
    ìš´ì„¸ í…ìŠ¤íŠ¸ ìƒì„± (ì˜ìƒì— í‘œì‹œë  ì§§ì€ ë¬¸êµ¬)

    Args:
        fortune_type: ìš´ì„¸ ì¢…ë¥˜

    Returns:
        ìš´ì„¸ ë¬¸êµ¬
    """
    prompt = f"""
{fortune_type}ì— ëŒ€í•œ ì§§ì€ ìš´ì„¸ ë¬¸êµ¬ë¥¼ ìƒì„±í•´ì¤˜.

ì¡°ê±´:
- 15ì ì´ë‚´
- ê¸ì •ì ì´ê³  í¬ë§ì ì¸ í†¤
- êµ¬ì²´ì ì¸ ì¡°ì–¸ë³´ë‹¤ëŠ” í‚¤ì›Œë“œ ì¤‘ì‹¬

ì˜ˆì‹œ:
- "ê¸ˆì „ìš´: ëŒ€ë°•ì˜ ê¸°ìš´!"
- "ì• ì •ìš´: ìš´ëª…ì  ë§Œë‚¨"
- "ê±´ê°•ìš´: í™œë ¥ ë„˜ì¹˜ëŠ” í•˜ë£¨"

JSON í˜•ì‹:
{{"fortune": "ìš´ì„¸ ë¬¸êµ¬"}}
"""

    client = _get_client()
    if not client or not config.OPENAI_API_KEY:
        return f"{fortune_type}: í–‰ìš´ì´ í•¨ê»˜í•´ìš”!"

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"},
            temperature=0.8
        )
        result = json.loads(response.choices[0].message.content)
        return result.get("fortune", f"{fortune_type}: ì¢‹ì€ ì¼ì´ ìƒê¸¸ ê±°ì˜ˆìš”!")
    except Exception as e:
        print(f"âŒ ìš´ì„¸ ìƒì„± ì‹¤íŒ¨: {e}")
        return f"{fortune_type}: í–‰ìš´ì´ í•¨ê»˜í•´ìš”!"
